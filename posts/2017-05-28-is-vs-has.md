---
post-class: dialogues
title: What we talk about when we talk about `instance`
twitter-title: What is an `instance`?
description: Dialogues in which we pedantically dissect the relationship between types, type constructors, typeclasses, and the instances that tie them all together. 
---

Julie: Oh, dear, there are still 119 unanswered tickets in the (haskellbook) Zendesk. This one I just opened is mad because we say a type "has an instance" of a typeclass.
Chris: What are people's objections to that?
Julie: That it can't be both "is an instance" and "has an instance" and the Haskell Report says "is" -- or if they haven't checked the report, then generally that they think "has" is confusing because they see "is" elsewhere, usually.
Chris: Hmmm, that it does. Very pointedly, too.
Julie: Yes. The book used to kind of alternate between the two "is" and "has" and it bothered me. I don't like the emphasis, though. I think there isn't as much constrast between the two things as other people seem to think.
Chris: I think "is-a" makes sense for the mathematical object and "has-a" makes sense for the Haskell type.
Julie: Maybe. I'm not sure enough about the distinction you're making. For me, as a learner, the thing that bothered me is that if a type "is" an instance of a typeclass, why do I have to write an instance (or derive one)? If i write a type, it *exists* before its typeclass instance, and the type declaration is not the same piece of code as its instance declaration. It can exist as a type without any typeclass instances. You can't do much with it, but it can. So, saying a type *is* an instance of a typeclass seemed pedagogically misleading to me.
Chris: Yes, that's kinda my thinking.
Julie: I mean, I understand what they're getting at with that, but as a learner I found that a difficult thing to grasp.
Chris: Like, there's the type itself, and the type-with-instances, and they both have the same name. The former *has* an instance, the latter *is* an instance. They both work, but "has-a" corresponds more to what you actually do when you're programming.
Julie: They do, yeah. But to keep things clear, I switched them all to "has". We do say "this type is a Monoid " as a kind of synecdoche of "this type-with-instances is a Monoid". I should write a form letter response I can send to the people who send in this complaint.
Chris: Appendix A: Things You Need to Shut the Fuck Up About. 

Don't you even say in the book that people use both and you made an intentional choice
Julie: I don't think so, but I can't remember for sure. It might be worth adding to the definitions page of the types chapter or something.

<hr>

Julie: I told you the guy who wants to argue about "is" vs "has" an instance of a type replied, right? I just re-read it and noticed that his argument consists of twice repeating verbatim what the Haskell Report says. I don't think he can articulate what the difference is without using the exact same phrasing.
Chris: Does he actually have an argument beyond an appeal to authority?
Julie: No, not at all. People did this a lot when I was first learning:
>Them: Types are instances of typeclasses. 
> Me: What does that mean, though? 
> Them: It means they are instances of the typeclass and implement the typeclass. 
> Me: OK, but what does that mean? 
> Them: It means they implement the typeclass. 

Like if they just repeat the same words enough times, I'll understand. Like people who think if they yell English at someone who doesn't speak English, eventually it'll sink in. Anyway, I had to read a bunch of things and a lot of examples to figure it out. I guess it would have helped if I'd understood earlier what it means to "implement a typeclass", but I didn't. And I didn't properly understand typeclasses until we wrote the Monoid chapter.
Chris: Just draw circles around some code and be like, "Look: This is a type. This is an instance. The type is clearly not the instance. QED."
Julie: LOL. The usage of "is" started to bother me in particular once I found out that some types, such as `Integer` and `Maybe`, are *monoidal* but don't have a `Monoid` instance. Because they form monoids under (at least) two different operations. 
Chris: I still have objections to saying a type is inherently monoidal or of any other class.
Julie: Martin, are we going to argue about monoids again? Addition and multiplication are canonical monoidal operations. I don't know if 'canonical' is a mathematically approved term.

Lists also admit of different monoids, but we've chosen one as the default. Is concatenation more *monoidal* than zipping? 

Chris: I think the only open question to that guy's point is whether we consider the instance definition to be "part of the type" in some sense.
Julie: Yeah, and that's a reasonable point. I chose "no" for the book to make it more apparent that the instance is a separate piece of code -- an implementation! -- whether you write it or derive it.
Chris: But we kinda pretend it is, right? Which is why we get all antsy about orphans and hand-wavy about typeclass cohesion.

<hr>

The replies to [this tweet](https://twitter.com/chris__martin/status/845453234256924672) rekindled the discussion.

Chris: I'm gonna get real tired of answering that question, aren't I?
Julie: Yes. It's okay with me if you want to switch for Joy. It's a somewhat metaphysical question, and some people are always going to prefer to stick the Report wording, for example. But to me it's like shrugging away a chunk of code that has to be written (or derived, but still).
Chris: Why does this man feel the right to demand I justify my word choice?
I can just not reply, right
jdog74@gmail.com
yes
when people emailed our book support, i felt pretty compelled to reply, but it's twitter, you're not obligated to anything
it's like getting upset when someone refers to a type declaration by calling it a type
do u want to write a blog post about this
Chris: A little. But a very short one, focusing not on the Haskell syntax, but on the math definitions.
e.g. "a semigroup is a set with a binary associative operation", so it is weird to say that `String` is an *instance of semigroup*. It is a set with a binary associative operation, so it *is* a semigroup, right? But the `instance` is sort of the definition of that operation, not `String` itself.
Julie: There's a semigroup over strings, isn't that the more mathematical way to put it? Not that they *are* or *have*? Or maybe that they *admit* a semigroup or form a semigroup under concatenation, I'm not sure. 
Chris: Now one might rightfully distinguish "is a semigroup", "is a `Semigroup` instance", and "is an instance of the `Semigroup` typeclass."
Julie: What's the distinction between the last two?
Chris: I didn't mean to say there are three different things, but there are three phrases and you could reasonably choose to draw the line at any point. There could be a difference between the last two if you choose to say "semigroup" for the math concept and "`Semigroup` typeclass" for the Haskell thing. But nobody would ever do that consistently so that's not a good prescription to fight for.
Julie: Oh, yes, I see. Isn't it "over"? I.e., that addition and multiplication are monoids *over* some kinds of numbers?
Chris: I think that's fair, yeah.
Julie: I think so, because those kinds of spatial things always bug me.
Chris: I'm not sure that's even a spatial metaphor. 
Julie: Yes. Do not make me bring up Lakoff. Wait, or is it integers, e.g., form a monoid *under* addition or multiplication? 
I think that might also be acceptable, but I'm not sure.  Yeah, you don't say "integers are a monoid", because they aren't without an operation. They *form* a monoid under addition or multiplication (and a ring under *both*? is that right?) 
Chris: Pretty sure I've heard "over" and "under," and I guess those are spatially consistent with each other.

<hr>

Julie: Correct me if I'm wrong but it seems like the case of the `Functor` over `Set` is an example of the has/is problem. It admits a functor -- it *can have* a functor over it -- but in Haskell, we've decided it shouldn't because of the way that `Functor` behaves and what we sort of expect from `Set`. So it seems to me like it *is* a `Functor` but doesn't *have* that instance declared, i.e., doesn't have an instance.
Chris: It depends whether you consider it to be a different type once it has an instance declared, I think.
Julie: I'm not sure what you mean.
Chris: idk
Julie: I think one might say that since the instance isn't declared, then it just *isn't* an instance of `Functor`, and then we're back at a similar metaphysical point. Although the functor over `Set` is a malfunctor, I suppose. You think it's okay until you try to `fmap` multiplication by zero or something and it destroys your whole set. I mean, that could be okay, but I suspect it would be considered bad by many people. Unexpectedly, my set was destroyed! Malfunctor is a good word, though. Typing on phones is awful; why do we put up with this?

<hr>

Julie: I find it unhelpful the way programmers talk about "an algebra," but it makes more sense as *an algebraic structure* -- at least to me, although I think this is a question of terminology, not meaning. An algebraic structure is a set with one or more operations defined on it that satisfies a list of axioms. I forget how we ended up defining "an algebra" in [haskellbook](http://haskellbook.com/), but we did try to define it because it was bothering me.
Chris: Things like semigroup, group, ring, field, etc., are those algebraic structures, or classifications of algebraic structures?
Julie: [quoting from Haskell book]: "And so, as we said above, *an algebra* refers to some operations and the set they operate over. Here again, we care less about the particulars of the values or data we're working with and more about the general rules of their use." So, those are algebraic structures. A monoid is an algebraic structure. A monoid is not just a binary associative operation but a structure that includes a set (a type, in Haskell?) *and* that operation. 
Chris: Wait, but ... so it's the *instance* that's the algrebraic structure?
Julie: Hmm.
Chris: Not "monoid" itself but like "the monoid of summed integers"?
Julie: I *think* that's right. A monoid in general is a set with a monoidal operation defined for it that follows some axioms or whatever, right? But that's a *monoid in general*. A specific monoid, a specific structure, I think it's right to say, e.g., "the monoid of summed integers" is an algebraic structure. Does that make sense? I do not have high confidence about this.
Chris: Yes, and that jibes with the Wikipedia summary.
Julie: Wow, I jibed with Wikipedia!

<hr>

Another day, another Twitter thread, in which someone said this:
> But there are no * or + operators for IO.

Julie: But `IO` does have a `Monoid`. This seems like a confusion of the operator for the algebra. Wait, `IO` is a `Monoid` now, right?
Chris: Pretty sure it's a monoid. GHC 8 and up, I think.
Julie: Well, that's sort of making me feel better about saying "has an instance." That type didn't used to have a monoidal operation defined for it. But now that it *has* an instance defined, it *is* a monoid: a type with the appropriate operation defined over it.

<hr> 

Julie: Hmm, Real World Haskell says: 
> This says that we are declaring a typeclass named BasicEq, and we'll refer to instance types with the letter a. An instance type of this typeclass is any type that implements the functions defined in the typeclass....The key is that, when you list the types of your functions, you must use that name to refer to instance types..... "For all types a, so long as a is an instance of BasicEq, isEqual ... 

It's like they start out saying "a is an instance *type*" if it implements the functions, then they elide the "type" and start saying "a is an instance of `Eq`" etc. I think I'm more comfortable saying "is an instance type" for "is a type for which an instance is defined" than just "is an instance" which on the surface seems to conflate the type declaration and the instance declaration.
Chris: "an instance type"? This is unfamiliar phrasing to me. I need to think about that.
Julie: Yeah, it's unusual phrasing, I think. To me it suggests no one is super comfortable with what we're talking about here.
Chris: I'm bothered immediately by the fact that it's not necessarily a *type*. We're really wanting for a word that encompasses both types and *type constructors*.
Julie: Yes, there is that, too. It conflates those two things in a way that is sorta okay when you're talking about `Eq` but not good for `Functor` and disastrous for the difference between `Monoid` and `Alternative`. Maybe"disastrous" is hyperbolic.
Julie: I've been trying to decide if i should try to include `Monad` in that talk proposal about different species of monoids. It might be too much for 30 minutes. I could probably spend 30 minutes only talking about why `Monad` is a monoid (in the cateogory  of endofunctors). I consider this nonobvious.
Chris: I was thinking about that recently. I couldn't remember what an endofunctor is.
Julie: In Haskell, it's just a functor. So, it's a monoid of functors, like `Alternative` is a monoid of *applicative functors*. Oh, and it's really .. "a monad in X is a monoid in the category of endofunctors of X" not just the category of endofunctors. 
Chris: Right. An endofunctor, T : X → X (in Haskell, a type constructor of kind `* -> *` with a `Functor` instance).
Julie: This phrasing has always bothered me a bit, but I think it's for similar reasons. It means "a monoid of type constructors that have instances of `Functor` (or `Applicative` in the case of `Alternative`)", or, if you prefer, type constructors that are functors or applicatives. But I've always thought it makes it sound like they are monoids of a sort of *function* called a functor, almost like they are monoids of the function type, but for a functor-function. And since both `Monad` and `Applicative` involve a functor operation, it's easy to make this mistake. But `Monad` and `Alternative` are monoids of type constructors that are functors. `Applicative` differs from `Monad` in where the extra "layer" comes from, so it needs `join` instead of (implicitly, I guess) a conjunctive monoid.  

Julie: RWH again:
> Now that you know how to define typeclasses, it's time to learn how to ***define instances of typeclasses***. (but, surely, if a type *is* an instance, then we don't need to define that instance, the same way we define a typeclass?) Recall that types ***are made instances of a particular typeclass*** by implementing the functions necessary for that typeclass. [emphasis mine]

<hr>

META

Julie: My next dialogue blog post might be us going back and forth about the "is an instance" vs "has an instance" question -- or is that too controversial? 
Chris: I like that a lot because it's another topic that deserves a level conversation, worth thinking about but not yelling about, without a single clear answer. 
Julie : I have a lot of bad opinions. I have the wrong opinion about is/has an instance, I'm pretty sure.
Chris: Well, I'm definitely with you on that one.
