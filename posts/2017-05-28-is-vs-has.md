---
post-class: dialogues
title: What we talk about when we talk about types
twitter-title: What we talk about when we talk about types.
description: Dialogues in which we pedantically dissect the relationship between types, type constructors, typeclasses, the instances that tie them all together, and set theory.
---

# What we talk about when we talk about types

### META

<div class="dialogue">

<div class="line">
<div class="name">Julie:</div> My next dialogue blog post might be us going back and forth about the "is an instance" vs "has an instance" question -- or is that too controversial?
</div>

<div class="line">
<div class="name">Chris:</div> I like that because it's another topic that deserves a level conversation, worth thinking about but not yelling about, without a single clear answer.
</div>

<div class="line">
Julie: I have a lot of bad opinions. I have the wrong opinion about is/has an instance, I'm pretty sure.
</div>

<div class="line">
<div class="name">Chris:</div> Well, I'm definitely with you on that one.
</div>

</div>

## Introduction

This series of dialogues diverges quite a bit from its original topic. We started off talking about whether *a type is an instance of a typeclass* or *a type has an instance of a typeclass* and why. That led us to talk more about the nature of types, type constructors, and typeclasses, which led to us talking about math, set theory and category theory, and what they have to do with types and typeclasses.


* The phrases we're discussing, using semigroup as an example:  

- is an instance of `Semigroup`
- has an instance of `Semigroup`
- is a semigroup  
- admits a semigroup  
- forms a semigroup under  
- a semigroup over

Some of these make less sense if we're talking about a typeclass like `Num`.

<div class="hr">●●●</div>

<div class="dialogue">

<div class="line">
<div class="name">Julie:</div> Oh, dear, there are still many unanswered tickets in the (haskellbook) Zendesk. This one I just opened is a complaint/question because we say a type "has an instance" of a typeclass.
</div>

<div class="line">
<div class="name">Chris:</div> What are people's objections to that?
</div>

<div class="line">
<div class="name">Julie:</div> That it can't be both "is an instance" and "has an instance" and the Haskell Report says "is" -- or if they haven't checked the report, then generally that they think "has" is confusing because they see "is" elsewhere.
</div>

<div class="line">
<div class="name">Chris:</div> Hmmm, that [the Report] does. Very pointedly, too.
</div>

<div class="line">
<div class="name">Julie:</div> Yes. The book used to kind of alternate between the two "is" and "has" and it bothered me. I don't like the emphasis, though. I think there isn't as much contrast between the two things as other people seem to think.
</div>

<div class="line">
<div class="name">Chris:</div> I think "is-a" makes sense for the mathematical object and "has-a" makes sense for the Haskell type.
</div>

<div class="line">
<div class="name">Julie:</div> Maybe. I'm not sure enough about the distinction you're making. For me, as a learner, the thing that bothered me is that if a type "is" an instance of a typeclass, why do I have to write an instance (or derive one)? If I write a type, it exists before its typeclass instance, and the type declaration is not the same piece of code as its instance declaration. It can exist as a type without any typeclass instances. You can't do much with it, but it can. So, saying a type *is* an instance of a typeclass seemed pedagogically misleading to me.
</div>

<div class="line">
<div class="name">Chris:</div> Yes, that's kinda my thinking.
</div>

<div class="line">
<div class="name">Julie:</div> I mean, I understand what they're getting at with that, but as a learner I found that a difficult thing to grasp.
</div>

<div class="line">
<div class="name">Chris:</div> Like, there's the type itself, and the type-with-instances, and they both have the same name. The former *has* an instance, the latter *is* an instance. They both work, but "has-a" corresponds more to what you actually do when you're programming.
</div>

<div class="line">
<div class="name">Julie:</div> They do, yeah. But to keep things clear, I switched them all to "has". We do say "this type is a `Monoid`" as a kind of synecdoche of "this type-with-instances is a `Monoid`". I should write a form letter response I can send to the people who send in this complaint.
</div>

<div class="hr">●●●</div>

<div class="line">
<div class="name">Julie:</div> I told you the guy who wants to argue about "is" vs "has" an instance of a type replied, right? I just re-read it and noticed that his argument consists of twice repeating verbatim what the Haskell Report says. I don't think he can articulate what the difference is without using the exact same phrasing.
</div>

<div class="line">
<div class="name">Chris:</div> Does he actually have an argument beyond an appeal to authority?
</div>

<div class="line">
<div class="name">Julie:</div> No.
</div>

<div class="line">
<div class="name">Chris:</div> Just draw circles around some code and be like, "Look: This is a type. This is an instance. The type is clearly not the instance. QED."
</div>

<div class="line">
<div class="name">Julie:</div> LOL. The usage of "is" started to bother me in particular once I found out that some types, such as `Integer` and `Maybe`, are *monoidal* but don't have a `Monoid` instance. Because they form monoids under (at least) two different operations.
</div>

<div class="line">
<div class="name">Chris:</div> I still have objections to saying a type is inherently monoidal, or of any other class.
</div>

<div class="line">
<div class="name">Julie:</div> Martin, are we going to argue about monoids again? Addition and multiplication are canonical monoidal operations. I don't know if 'canonical' is a mathematically approved term.

Lists also admit different monoids, but we've chosen one as the default. Is concatenation *more monoidal* than zipping?
</div>

<div class="line">
<div class="name">Chris:</div> I think the only open question to that guy's point is whether we consider the instance definition to be "part of the type" in some sense.
</div>

<div class="line">
<div class="name">Julie:</div> Yeah, and that's a reasonable point. I chose "no" for the book to make it more apparent that the instance is a separate piece of code -- an implementation! -- whether you write it or derive it.
</div>

<div class="line">
<div class="name">Chris:</div> But we kinda pretend it is, right? Which is why we get all antsy about orphans and hand-wavy about typeclass cohesion.
</div>

</div>

<div class="hr">●●●</div>

One day, Chris tweeted this:

> Typeclass instances can be very boilerplatey but usually in a satisfyingly shove-it-under-the-rug-and-don't-worry-about-it-again sort of way

And the replies rekindled our discussion.

<div class="dialogue">

<div class="line">
<div class="name">Chris:</div> I'm gonna get real tired of answering the question of whether an *instance* and an *instance declaration* are the same thing, aren't I?
</div>

<div class="line">
<div class="name">Julie:</div> Yes. It's okay with me if you want to switch for Joy. It's a somewhat metaphysical question, and some people are always going to prefer to stick the Report wording, for example. But to me it's like shrugging away a chunk of code that has to be written (or derived, but still).
</div>

<div class="line">
<div class="name">Chris:</div> Why does this man feel the right to demand I justify my word choice? I can just not reply, right.
</div>

<div class="line">
<div class="name">Julie:</div> Yes. When people email our book support, I feel compelled to reply, but it's Twitter, you're not obligated to anything.
</div>

<div class="line">
<div class="name">Chris:</div> It's like getting upset when someone refers to a type declaration by calling it a type.
</div>

<div class="line">
<div class="name">Julie:</div> Do you want to write a blog post about this?
</div>

<div class="line">
<div class="name">Chris:</div> A little. But a very short one, focusing not on the Haskell syntax, but on the math definitions. For example, "a semigroup is a set with a binary associative operation", so it is weird to say that `String` is an *instance of semigroup*. It is a set with a binary associative operation, so it *is* a semigroup, right? But the `instance` is sort of the definition of that operation, not `String` itself.
</div>

<div class="line">
<div class="name">Julie:</div> There's a semigroup over strings -- actually, more than one -- isn't that the more mathematical way to put it? Not that they *are* or *have*? Or maybe that they *admit* a semigroup or form a semigroup under concatenation, I'm not sure.
</div>

<div class="line">
<div class="name">Chris:</div> Now one might rightfully distinguish "is a semigroup", "is a `Semigroup` instance", and "is an instance of the `Semigroup` typeclass."
</div>

<div class="line">
<div class="name">Julie:</div> What's the distinction between the last two?
</div>

<div class="line">
<div class="name">Chris:</div> I didn't mean to say there are three different things, but there are three phrases and you could reasonably choose to draw the line at any point. There could be a difference between the last two if you choose to say "semigroup" for the math concept and "`Semigroup` typeclass" for the Haskell thing. But nobody would ever do that consistently so that's not a good prescription to fight for.
</div>

<div class="line">
<div class="name">Julie:</div> Another weird thing, to me, about saying the type is the instance: a `String` has at least two operations under which it forms a semigroup, right? So, okay, it is, or *admits*, a semigroup. But saying it is an instance of `Semigroup` seems strange, from a programming perspective. I suppose it's the CT idea that we have a structure called semigroup and the set `String` is an instance, or an object in that category or something? With the typeclass, as with the category theoretic notion, we don't really care what the operations are, just that there exists some operation under which it forms this structure. So, that's all cool, it just seems weird to talk about Haskell that way. When we program, we do care about those operations and how they work, so we care about the *instance declaration*. But this gets weirder, in my *humble* opinion, when you're talking about, say, `Num`. What is the algebraic structure called `Num`?
</div>

<div class="line">
<div class="name">Chris:</div> `Num` is an algebraic structure; it's like a fucked up ring with some other shit tacked on.
</div>

</div>

<div class="hr">●●●</div>

<div class="dialogue">

<div class="line">
<div class="name">Julie:</div> Correct me if I'm wrong but it seems like the case of the `Functor` over `Set` is an example of the has/is problem. [It admits a functor](https://gist.github.com/afldcr/1586c6ec23556aa1000170a22e8cdbbe) -- it *can have* a functor over it -- but in Haskell, we've decided it shouldn't because of the way that `Functor` behaves and what we sort of expect from `Set`. So it seems to me like it *is* a `Functor` but doesn't *have* that instance declared, i.e., doesn't have an instance.
</div>

<div class="line">
<div class="name">Chris:</div> It depends whether you consider it to be a different type once it has an instance declared, I think.
</div>

<div class="line">
<div class="name">Julie:</div> I'm not sure what you mean.
</div>

<div class="line">
<div class="name">Chris:</div> idk
</div>

<div class="line">
<div class="name">Julie:</div> I think one might say that since the instance isn't declared, then it just *isn't* an instance of `Functor`, and then we're back at a similar metaphysical point. Although the functor over `Set` is a malfunctor, I suppose. You think it's okay until you try to `fmap` multiplication by zero or something and it destroys your whole set. I mean, that could be okay, but I suspect it would be considered bad by many people. Unexpectedly, my set was destroyed! Malfunctor is a good word, though.
</div>

</div>

<div class="hr">●●●</div>

<div class="dialogue">

<div class="line">
<div class="name">Julie:</div> I find it unhelpful the way programmers talk about "an algebra," but it makes more sense as *an algebraic structure* -- at least to me, although I think this is a question of terminology, not meaning. An algebraic structure is a set with one or more operations defined on it that satisfies a list of axioms. I forget how we ended up defining "an algebra" in [haskellbook](http://haskellbook.com/), but we did try to define it because it was bothering me.
</div>

<div class="line">
<div class="name">Chris:</div> Things like semigroup, group, ring, field, etc., are those algebraic structures, or classifications of algebraic structures?
</div>

<div class="line">
Julie, quoting from Haskell book: "And so, as we said above, *an algebra* refers to some operations and the set they operate over. Here again, we care less about the particulars of the values or data we're working with and more about the general rules of their use." So, those are algebraic structures. A monoid is an algebraic structure. A monoid is not just a binary associative operation but a structure that includes a set (a type, in Haskell?) *and* that operation.
</div>

<div class="line">
<div class="name">Chris:</div> Wait, but ... so it's the *instance* that's the algebraic structure? Not "monoid" itself but like "the monoid of summed integers"?
</div>

<div class="line">
<div class="name">Julie:</div> I *think* that's right. A monoid in general is a set with a monoidal operation defined for it that follows some axioms or whatever, right? But that's a *monoid in general*. A specific monoid, a specific structure, I think it's right to say, e.g., "the monoid of summed integers" is an algebraic structure. Does that make sense? I do not have high confidence about this.
</div>

<div class="line">
<div class="name">Chris:</div> Yes, and that jibes with the Wikipedia summary.
</div>

</div>

<div class="hr">●●●</div>

Another day, another Twitter thread, in which someone said this:  

<blockquote>But there are no * or + operators for IO.</blockquote>

<div class="dialogue">

<div class="line">
<div class="name">Julie:</div> But `IO` does have a `Monoid`. This seems like a confusion of the operator for the algebra. Wait, `IO` is a `Monoid` now, right?
</div>

<div class="line">
<div class="name">Chris:</div> Pretty sure it's a monoid. GHC 8 and up, I think.
</div>

<div class="line">
<div class="name">Julie:</div> Well, that's sort of making me feel better about saying "has an instance." That type didn't used to have a monoidal operation defined for it. But now that it *has* an instance defined, it *is* a monoid: a type with the appropriate operation defined over it.
</div>

</div>

<div class="hr">●●●</div>

<div class="dialogue">

<div class="line">
<div class="name">Julie:</div> Hmm, Real World Haskell says:

<blockquote> This says that we are declaring a typeclass named BasicEq, and we'll refer to instance types with the letter a. An instance type of this typeclass is any type that implements the functions defined in the typeclass....The key is that, when you list the types of your functions, you must use that name to refer to instance types... "For all types a, so long as a is an instance of BasicEq, isEqual...

It's like they start out saying "`a` is an instance *type*" if it implements the functions, then they elide the "type" and start saying "a is an instance of `Eq`" etc. I think I'm more comfortable saying "is an instance type" for "is a type for which an instance is defined" than just "is an instance" which on the surface seems to conflate the type declaration and the instance declaration.
</div>

<div class="line">
<div class="name">Chris:</div> "an instance type"? This is unfamiliar phrasing to me. I need to think about that.
</div>

<div class="line">
<div class="name">Julie:</div> Yeah, it's unusual phrasing, I think. To me it suggests no one is super comfortable with what we're talking about here.
</div>

<div class="line">
<div class="name">Chris:</div> I'm bothered immediately by the fact that it's not necessarily a *type*. We're really lacking a word that encompasses both types and *type constructors*.
</div>

<div class="line">
<div class="name">Julie:</div> Yes, there is that, too. It conflates those two things in a way that is sorta okay when you're talking about `Eq` but not good for `Functor` and disastrous for the difference between `Monoid` and `Alternative`. Maybe "disastrous" is hyperbolic.

I've been trying to decide if i should try to include `Monad` in that talk proposal about different species of monoids. It might be too much for 30 minutes. I could probably spend 30 minutes only talking about why `Monad` is a monoid (in the cateogory of endofunctors). I consider this nonobvious.
</div>

<div class="line">
<div class="name">Chris:</div> I was thinking about that recently. I couldn't remember what an endofunctor is.
</div>

<div class="line">
<div class="name">Julie:</div> In Haskell, it's just a functor. So, it's a monoid of functors, like `Alternative` is a monoid of *applicative functors*. Oh, and it's really .. "a monad in X is a monoid in the category of endofunctors of X" not just the category of endofunctors.
</div>

<div class="line">
<div class="name">Chris:</div> Right. An endofunctor, T : X → X (in Haskell, a type constructor of kind `* -> *` with a `Functor` instance).
</div>

<div class="line">
<div class="name">Julie:</div> This phrasing has always bothered me a bit, but I think it's for similar reasons. It means "a monoid of type constructors that have instances of `Functor` (or `Applicative` in the case of `Alternative`)", or, if you prefer, type constructors that are functors or applicatives. But I've always thought it makes it sound like they are monoids of a sort of *function* called a functor, almost like they are monoids of the function type, but for a functor-function. And since both `Monad` and `Applicative` involve a functor operation, it's easy to make this mistake. But `Monad` and `Alternative` are monoids of type constructors that are functors (but `Monad` also involves fmapping, whereas `Alternative` does not). `Applicative` differs from `Monad` in where the extra "layer" comes from, so it needs `join` instead of (implicitly, I guess) a conjunctive monoid.
</div>

<div class="line">
<div class="name">Julie:</div> RWH again:
<blockquote> Now that you know how to define typeclasses, it's time to learn how to ***define instances of typeclasses***. [emphasis added]

But, surely, if a type *is* an instance, then we don't need to define that instance, the same way we define a typeclass?)  

<blockquote> Recall that types ***are made instances of a particular typeclass*** by implementing the functions necessary for that typeclass. [emphasis added]
</div>

</div>

<div class="hr">●●●</div>

During this next conversation, Julie was on airplanes, texting on my phone, wondering why we tolerate phone autocorrects.

<div class="dialogue">

<div class="line">
<div class="name">Julie:</div> I pushed the start of that dialogue about types and instances, if you want to take a look at it.
</div>

<div class="line">
<div class="name">Chris:</div>
<blockquote> Oh, and it's really .. "a monad in X is a monoid in the category of endofunctors of X" not just the category of endofunctors.

I think I missed that the first time around. That... makes a lot more sense. I've always read "the category of endofunctors" literally, to mean *all endofunctors*.
</div>

<div class="line">
<div class="name">Julie:</div> Yeah. I did too for a long time, and still forget it sometimes. Oh, I just had a thought. Is functor (or endofunctor) considered an algebraic structure? That is, a set with a *functor* operation over it?
</div>

<div class="line">
<div class="name">Chris:</div> I suppose it must be. It's easy to forget about functor because it's the best abstraction.
</div>

<div class="line">
<div class="name">Julie:</div> Suddenly it makes more sense to me. I guess a monad in Hask is a monoid in the category of functors of Hask, i.e. the type constructors which have `Functor` instances.
</div>

<div class="line">
<div class="name">Chris:</div> There's rarely any question about "which `fmap`" to use; it's nearly always clear, so we don't talk about it like we say "a type and a semigroup operator", but we don't say "a type constructor and a functor operation" because it's not "a" functor operation, it's always "the" obvious/only `fmap` implementation.
</div>

<div class="line">
<div class="name">Julie:</div> Right. I think it's also less clear what the essence of a functor operation is, unlike semigroup/monoid. We don't seem to talk much about what *is* a functor the way we do with semigroup/monoid. Joy is going to, though.
</div>

<div class="line">
<div class="name">Chris:</div> Can we say monad is a monoid in the category of type constructors for which there is a functor? That's what screwed me up, thinking it was a monoid over the values, where really it's a monoid over the type constructors, right? It's also hard for me that we end up alternating between the set theory definition of monoid and the category theory definition.
</div>

<div class="line">
<div class="name">Julie:</div> Ooooh, what do you mean? Because I'm not aware of this, I don't think.
</div>

<div class="line">
<div class="name">Chris:</div> Milewski finally drove that point home for me, I think.
</div>

<div class="line">
<div class="name">Julie:</div> Is it something we could clarify by adding some prose to that dialogue post?
</div>

<div class="line">
<div class="name">Chris:</div> Hm. I'm still not confident enough to write about it.

What you and I usually talk about is the set theory notion of monoid: a set, one element of the set being an identity, a binary associative operation on the set.
</div>

<div class="line">
<div class="name">Julie:</div> Because in the category theory notion, there's not a distinction between conjunction and disjunction and the operation details themselves don't matter?
</div>

<div class="line">
<div class="name">Chris:</div> Category theory: a monoid is a category with exactly one object. We say "a monoid over X", sometimes I puzzle between whether X refers to a set, or to the single object in a monoidal category.
</div>

<div class="line">
<div class="name">Julie:</div> I don't think the notion of a one-object category is all that useful, though, when we're talking about Haskell. In the set theory case, I think "a set" means "a type" in Haskell. In the category theory it means "the set of types." ...And type constructors? I think in that sense the distinction between types and type constructors is irrelevant. It's too far abstracted for that to matter. So, in that sense, I don't think it's very helpful for thinking about Haskell, except for doing type-level programming, maybe.
</div>

<div class="line">
<div class="name">Chris:</div> I don't think the set theory notion is any different in that regard. The set definition of a monoid makes no mention of what the operation details are either.
</div>

<div class="line">
<div class="name">Julie:</div> Can't quite agree with that.
</div>

<div class="line">
<div class="name">Chris:</div> I think they're entirely equivalent definitions.
</div>

<div class="line">
<div class="name">Julie:</div> Technically equivalent, yes. But not functionally equivalent, by which I mean they allow us to know and talk about different things. What do you know about a Haskell Monoid from knowing it's a one-object category with arrows pointing only to itself? It's useful for some things but only after knowing about the set theory notion of monoids.
</div>

<div class="line">
<div class="name">Chris:</div> What do you know about a set theory monoid knowing there's a binary associative operation, without talking about what that operation is?
</div>

<div class="line">
<div class="name">Julie:</div> Ah but we do know what those operations are in set theory because set theory is Boolean algebra. When we're talking about sets, we do know what the monoidal operations are.
</div>

<div class="line">
<div class="name">Chris:</div> What are they?
</div>

<div class="line">
<div class="name">Julie:</div> Conjunction and disjunction.
</div>

<div class="line">
<div class="name">Chris:</div> But if all you know if that you have a monoid, you don't know which one it is.
</div>

<div class="line">
<div class="name">Julie:</div> That is true. At that level we don't care yet. And most (?) sets, like most types in Haskell, have at least two, a conjunctive and a disjunctive monoid.
</div>

<div class="line">
<div class="name">Chris:</div> The monoid abstraction removes that detail just as much as the category does.
</div>

<div class="line">
<div class="name">Julie:</div> Not as much. CT is a further level of abstraction.
</div>

<div class="line">
<div class="name">Chris:</div> If you map the category arrows to functions that they represent, now you can talk about conjunction and disjunction again.
</div>

<div class="line">
<div class="name">Julie:</div> Then we're talking about set theory though, at least when the objects are sets. Which is my point. Because now we care about the objects and arrows in that category and what sorts of things they are. They lose some polymorphism in a sense. It's like the relationship between parametricity and constrained polymorphism a bit.
</div>

<div class="line">
<div class="name">Chris:</div> Yeah, so it does take one restriction: the arrows have to be a set in order to go from category theory monoid to set theory monoid. Nothing stops me from talking about what the arrows in a category represent and using that to reason about the category, does it?
</div>

<div class="line">
<div class="name">Julie:</div> No, it's just that then you're not really at the level of abstraction that category theory exists for. Then you're talking about something more concrete, even if not yet fully concrete.
</div>

<div class="line">
<div class="name">Chris:</div> We can talk about a monoidal category in which the arrows represent additions or multiplications.
</div>

<div class="line">
<div class="name">Julie:</div> Now I think you're conflating the set theory notion with the category theory one.
</div>

<div class="line">
<div class="name">Chris:</div> But isn't abstract algebra also the wrong level of abstraction for that?
</div>

<div class="line">
<div class="name">Julie:</div> Wrong for what purpose?
</div>

<div class="line">
<div class="name">Chris:</div> Talking about additions or multiplications solely as a monoidal algebra, not talking about their relationships in a ring or something.
</div>

<div class="line">
<div class="name">Julie:</div> I have lost the point of this. First, you said you were confused because you couldn't tell sometimes if we were talking about the set theory notion or the category theory notion, but now you appear to be arguing that they're the same thing.
</div>

<div class="line">
<div class="name">Chris:</div> Equivalent things.
</div>

<div class="line">
<div class="name">Julie:</div> They are and they aren't; it depends on your point. It depends on what we are talking about them *for*. Usually when I'm talking about monoids, what I care about is closer to the set theory notion because the category theory notion is not very useful for thinking/talking about the monoidal operations, and it's not meant to be.
</div>

<div class="line">
<div class="name">Chris:</div> Yeah, that makes sense.
</div>

<div class="line">
<div class="name">Julie:</div> Category theory exists so we can talk about things without caring about what kinds of things they are, only comparing them by what they have in common.
</div>

<div class="line">
<div class="name">Chris:</div> That confused me for a long time. Basically up to just now.
</div>

<div class="line">
<div class="name">Julie:</div> It's like when we talk about very abstract syntax in linguistics. In some sense it maps to languages that people speak, but we're abstracting out that far because we want to talk about certain properties of language without caring about the implementation details of how humans construct meaningful sentences and speak or write them.

That's why I compared it to parametric versus constrained polymorphism. At the level of parametricity, we can't know, don't want to know, what the type will be, so there's little that we do know about what we're doing. That's useful for some things. At the level of constrained polymorphism, we know *some* things (like when we talk about monoids in set theory) but not everything, not yet. It's not until things become concrete (as they do when we talk about "integers form a monoid under...") that we really know a lot of detail. We can talk about all those levels, they all have their uses, things can be equivalent between those levels, but we can still make useful distinctions and use those levels of abstraction for different purposes, to make it easier to talk about precisely the thing we care about at the time.

I'm about to get on the next plane. I'm all, "I can't board right now; I'm too busy arguing about math.""
</div>

<div class="line">
<div class="name">Chris:</div> I still feel fuzzy about a lot of this.
</div>

<div class="line">
<div class="name">Julie:</div> Yeah, a lot of what I just said was stuff I've never thought before, so I don't know yet if I'm way off base or what. I have thought about how the kind of syntax I used to do is like the category theory of language, though.

I did work on real languages, too, and their specific syntax, but some of what I did is to be able to compare cross-linguistically without talking at all about what the grammar of any particular language looks like. Like category theory is so abstract that triangles and types and integers and functions maybe, depending on the category, can be seen as more similar than different because they're all just objects. And multiplication and addition are the same too. The difference between them has been abstracted away. And yet it's relevant to us, as programmers.

In set theory, I suppose the distinction between conjunction and integral multiplication for example has also been abstracted away. So what comparisons it allows us to make and examine and talk about are different from when we talk about more concrete things or category theory notions. There is purpose to all the layers of abstraction, though. At each layer we can "see" and talk about different things and it's wonderful and exciting.

Category theory is so close to the metal, where "metal" means brain, something fundamental about how our brains work. It's exciting as hell. Sorry. I'm having a religious moment here.
</div>

<div class="line">
<div class="name">Chris:</div> Yes, this sounds good. I was intrigued when I saw [Milewski](https://www.youtube.com/watch?v=I8LbkfSSR58) lay out that notion of category theory being how our brains work.
</div>

<div class="line">
<div class="name">Julie:</div> wat
</div>

<div class="line">
<div class="name">Chris:</div> I don't think I'd heard anyone describe that.
</div>

<div class="line">
<div class="name">Julie:</div> I could swear I watched that but the way you describe it are not things I remember about it at all.
</div>

<div class="line">
<div class="name">Chris:</div> That's the theme of the first lecture.
</div>

<div class="line">
<div class="name">Julie:</div> I've had this thought about it and syntax being about how our brains really fundamentally work for a long time, like since the first time I heard [Snively and Laucher's talk about types](https://www.youtube.com/watch?v=SWTWkYbcWU0) that convinced me to learn Haskell because types are like generative syntax.
</div>

<div class="line">
<div class="name">Chris:</div> He makes a joke about how even the language of "arrows" is an allusion to something humans have been doing for tens of thousands of years.
</div>

<div class="line">
<div class="name">Julie:</div> Maybe I accidentally started not with the first lecture or something. Oh, well, there's [Lakoff](http://cogling.wikia.com/wiki/Conceptual_metaphor) again.
</div>

<div class="line">
<div class="name">Chris:</div> oh?
</div>

<div class="name">Julie:</div> METAPHORS. Metaphors are like the kan extensions of language.

</div>

<div class="hr">●●●</div>

Then Chris tweeted this:

<blockquote> I think I'm coming to realize this:

<blockquote> Talk to your kids about category theory, or else Haskellers might talk to them first.

<blockquote> Learn Haskell, learn category theory, but for god's sake not at the same time.

<blockquote> Here's what happened to me: All the same people I saw talking about Haskell, I also saw talking about CT. From that, I made wrong inferences

And Julie said "agh" and then responded:

<blockquote> You can learn either, or neither, or both at the same time, like learning French and Spanish at the same time.

<div class="dialogue">

<div class="line">
<div class="name">Chris:</div> I thought this revelation was sort of related to our chat. For a long time I thought "monoid" was only a category theory concept. I didn't know it generalized monoids from set theory. So I thought the `Monoid` typeclass was just this sort of bastardized version of the category concept, and kept trying to relate it to that, when really I should have been thinking a lot more about sets in a lot of these discussions.
</div>

<div class="line">
<div class="name">Julie:</div> I see. I understand, but I don't think telling people not to do them at the same time is necessary. I moved naturally from types to set theory to category theory because I already had a grounding in Boolean algebra, I think. For me all it took was realizing that there are sum and product types and what Haskell calls monoids followed the same pattern. To be clear, in Boolean algebra and I think set theory, I don't remember seeing the word *monoid* but the concept is there.
</div>

<div class="line">
<div class="name">Chris:</div> I guess it was more commentary about learning CT *from* Haskellers more than about literally learning at the same time.
</div>

<div class="line">
<div class="name">Julie:</div> Or thinking that learning CT will teach you important things about Haskell. It could, but not for day-to-day making web apps in Haskell. I do think "ignore Haskellers who try to explain a Haskell thing via category theory" is good advice. Unless it's actually `Category` or something, but this is way outside normal Haskell you need to do programming. Thus the "French-Spanish" analogy. They have some things in common, but they're not the same. They are different languages. Perhaps French and Romanian would have been more apt. Also where the analogy holds: there are a bunch of cognates, but that doesn't mean they are the same word.

Plane still hasn't left, but I was able to plug my phone in so I can keep arguing with you. You're not tired of me yet?
</div>

<div class="line">
<div class="name">Chris:</div> Not a bit.
</div>

<div class="line">
<div class="name">Julie:</div> Also, sometimes people pick weird things from category theory, find them not useful, then inappropriately generalize to things that are useful. Groups and rings may not be super useful in programming, but monoids sure are, at least when we're talking about types and type constructors.
</div>

<div class="line">
<div class="name">Chris:</div> I don't know, I think some of your gripes would be addressed by a proper `Ring` typeclass. List could be generalized in with the numbers and stuff.
</div>

<div class="line">
<div class="name">Julie:</div> Well, lists are weird. I think lists deserve special treatment. You know how monoids are a class of types not type constructors?
</div>

<div class="line">
<div class="name">Chris:</div> Yeah.
</div>

<div class="line">
<div class="name">Julie:</div> That's why it's a monoid over [a] not []. The `Maybe` monoids can ignore whatever `a` value there might be, although you can also do `Just (a <> a)`. But the list monoids don't work the same. They are a conjunction or disjunction of the `a` values, not the list constructor. Whereas the `Maybe` monoids are conjunctions or disjunctions of `Maybe`. Sorry. I don't know why I'm mansplaining this to you.
</div>

</div>

<div class="hr">●●●</div>

<div class="dialogue">

<div class="line">
<div class="name">Julie:</div> Sometimes I think Milewski isn't talking about category theory so much as about set theory.
</div>

<div class="line">
<div class="name">Chris:</div> He's definitely coming at it as "a generalization of set theory," which I think is an appropriate direction to come from if you're trying to relate it to programming.
</div>

<div class="line">
<div class="name">Julie:</div> Categories don't care what the objects are. When we talk about Haskell, we're nearly always talking about sets. So then could we call it set theory?
</div>

<div class="line">
<div class="name">Chris:</div> Yeah, what I have yet to find out is what we gain from category theory.
</div>

<div class="line">
<div class="name">Julie:</div> For Haskell? Or for mathematics?
</div>

<div class="line">
<div class="name">Chris:</div> Usually with abstractions like this, you go up in abstraction, learn something there, and then come back down and apply whatever theorem or something you've learned. With category theory we seem to be giving a lot of names to things, but I've yet to know what we've learned from it, what we come back down from it with, that we couldn't have done in set theory.
</div>

<div class="line">
<div class="name">Julie:</div> Again, do you mean for Haskell or for mathematics?
</div>

<div class="line">
<div class="name">Chris:</div> Either. Well, Haskell, I guess.
</div>

<div class="line">
<div class="name">Julie:</div> For Haskell, I have no answer. I don't think it's given us much that set theory did not already give us. For mathematics, I think it shows us similarities between what were formerly disparate fields.
</div>

<div class="line">
<div class="name">Chris:</div> Maybe it's the progenitor for some insights that were brought to set theory from other fields, which is useful and valuable for certain things.
</div>

<div class="line">
<div class="name">Julie:</div> Yes, I think that's probably true, and I don't know enough of that history, perhaps, to say. It might be that it provided some motivation for Haskell to treat the function type like any other type, for example, or some justification for that.
</div>

<div class="line">
<div class="name">Chris:</div> I really liked Milewski's introduction to Kleisli categories, and now I'm wondering...why not forget the categories and just teach people about Kleisli mappings in sets?
</div>

<div class="line">
<div class="name">Julie:</div> Yeah, I'm hoping that as I do understand more about category theory *per se*, I'll see more of what we get from it for Haskell that we couldn't get from set theory. Maybe some stuff in type-level programming? But I sort of feel sometimes that Haskellers bring up category theory a lot, instead of set theory, because it sounds cooler. I say this as a person who likes category theory for its own sake.
</div>

<div class="line">
<div class="name">Chris:</div> Yes, or, to be more charitable, perhaps bringing up CT in appreciation for where some ideas came from.
</div>

<div class="line">
<div class="name">Julie:</div> I guess the point is when we're talking about Haskell, the only category we care about is Hask, and the objects there are types (and presumably type constructors) and the morphisms are functions. Which means when we talk about Hask, we're already talking about set theory, I think.
</div>

<div class="line">
<div class="name">Chris:</div> Yes.
</div>

<div class="line">
<div class="name">Julie:</div> Oh, hmm, and also morphisms in category theory are monomorphic, I think, not polymorphic, whereas for Haskell, we like polymorphic functions.
</div>

<div class="line">
<div class="name">Chris:</div> I think what categories bring to the table is *design*, this notion of things being natural, conceptually small?
</div>

<div class="line">
<div class="name">Julie:</div> Yes. Design. Like typeclasses themselves. I think those are conceptually category theoretic. Like we can see a pattern repeated across a bunch of apparently unrelated things, so we make a typeclass, and it is in some way like taking a bunch of not-obviously-related things and finding the thing they share in common and calling it a category.

And also monad. That idea did come from category theory, not set theory -- although, again, category theory generalizes set theory so they are not totally distinct. Anyway, I don't think the Haskell version maps perfectly to the CT version, but the idea is there.
</div>

</div>
